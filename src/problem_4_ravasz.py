# -*- coding: utf-8 -*-
"""ravasz rathi.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1I4Y8J98lwYoTu2tAR1XGerZTqjzgNMWZ

Import required dependencies
"""

import matplotlib.pyplot as plt #for plotting
import numpy as np #array manipulations
import networkx as nx #for graph making
import pandas as pd #storing dataframe
import time

"""#Make a graph for celegans dataset"""

celegans_g = nx.Graph()

f = open("/content/out.dimacs10-celegans_metabolic", "r")
lines = f.readlines()
lines.pop(0)
for line in lines:
    l = line.split()
    celegans_g.add_edge(int(l[0]), int(l[1]))
    #celegans.append([int(l[0]), int(l[1])])
celegans_mat = nx.adjacency_matrix(celegans_g).todense()
celegans = nx.to_pandas_adjacency(celegans_g, dtype=int)
print("adjacency matrix for celegans data\n")
print(celegans)

"""Create a class with methods to compute distances between communities and merge a pair of communities with least distance (single linkage method)."""

class length_find_class(object):
    def __init__(self):
        pass

    def compute_length(self,communities):
        """
        matrix creation for distances between individual nodes and merged communities.
        """
        length_mat = np.zeros((len(communities),len(communities)))
        for i in range(length_mat.shape[0]):
            for j in range(length_mat.shape[0]):
                if i!=j:
                    length_mat[i,j] = float(self.length_calculate(communities[i],communities[j]))
                else:
                    length_mat[i,j] = 10**4
        return length_mat

    def length_calculate(self,community1,community2):
        "for finding distance between 2 individual nodes or 2 communities"
        dist = []
        for i in range(len(community1)):
            for j in range(len(community2)):
                try:
                    dist.append(np.linalg.norm(np.array(community1[i])-np.array(community2[j])))
                except:
                    dist.append(self.internodelength(community1[i],community2[j]))
        return min(dist)

    def internodelength(self,s1,s2):
        """
        for finding distance between a node and a community.
        """
        if str(type(s2[0]))!='<class \'list\'>':
            s2=[s2]
        if str(type(s1[0]))!='<class \'list\'>':
            s1=[s1]
        m = len(s1)
        n = len(s2)
        dist = []
        if n>=m:
            for i in range(n):
                for j in range(m):
                    if (len(s2[i])>=len(s1[j])) and str(type(s2[i][0])!='<class \'list\'>'):
                        dist.append(self.intercommlength(s2[i],s1[j]))
                    else:
                        dist.append(np.linalg.norm(np.array(s2[i])-np.array(s1[j])))
        else:
            for i in range(m):
                for j in range(n):
                    if (len(s1[i])>=len(s2[j])) and str(type(s1[i][0])!='<class \'list\'>'):
                        dist.append(self.intercommlength(s1[i],s2[j]))
                    else:
                        dist.append(np.linalg.norm(np.array(s1[i])-np.array(s2[j])))
        return min(dist)

    def intercommlength(self,cl,community):
        if community[0]!='<class \'list\'>':
            community = [community]
        dist   = []
        for i in range(len(cl)):
            for j in range(len(community)):
                dist.append(np.linalg.norm(np.array(cl[i])-np.array(community[j])))
        return min(dist)

prog_data = [[i] for i in range(celegans_mat.shape[0])]
communities     = [[list(celegans_mat[i])] for i in range(celegans_mat.shape[0])]
m = len(communities)
distcal  = length_find_class()

start_time = time.time()

for _ in range(1,6): #5 steps
    print("Step :- ", _)
    print('#communities before clustering    :- ',m)
    length_mat = distcal.compute_length(communities)
    community_ind_needed = np.where(length_mat==length_mat.min())[0]
    value_to_add      = communities.pop(community_ind_needed[1])
    communities[community_ind_needed[0]].append(value_to_add)

    print('1st node to be merged in this step                   :-',prog_data[community_ind_needed[0]])
    print('2nd node to be merged in this step                   :-',prog_data[community_ind_needed[1]])

    prog_data[community_ind_needed[0]].append(prog_data[community_ind_needed[1]])
    prog_data[community_ind_needed[0]] = [prog_data[community_ind_needed[0]]]
    v = prog_data.pop(community_ind_needed[1])
    m = len(communities)

    print('All communities present      :-',prog_data)
    print('Communities merged in this step                 :-',prog_data[community_ind_needed[0]])
    print('#Communities After clustering     :-',m)
    print('\n')

end_time = time.time()
print("\ntime taken = ",end_time-start_time)

"""# Make a graph for jazz dataset

"""

jazz_g = nx.Graph()

f = open("/content/out.arenas-jazz", "r")
lines = f.readlines()
lines.pop(0)
for line in lines:
    l = line.split()
    jazz_g.add_edge(int(l[0]), int(l[1]))
jazz_mat = nx.adjacency_matrix(jazz_g).todense()
jazz = nx.to_pandas_adjacency(jazz_g, dtype=int)
print("adjacency matrix for jazz data\n")
print(jazz)

prog_data = [[i] for i in range(jazz_mat.shape[0])]
communities     = [[list(jazz_mat[i])] for i in range(jazz_mat.shape[0])]
m = len(communities)
distcal  = length_find_class()

start_time = time.time()
for _ in range(1,6): #5 steps
    print("Step :- ", _)
    print('#communities before clustering    :- ',m)
    length_mat = distcal.compute_length(communities)
    community_ind_needed = np.where(length_mat==length_mat.min())[0]
    value_to_add      = communities.pop(community_ind_needed[1])
    communities[community_ind_needed[0]].append(value_to_add)

    print('1st node to be merged in this step                   :-',prog_data[community_ind_needed[0]])
    print('2nd node to be merged in this step                   :-',prog_data[community_ind_needed[1]])

    prog_data[community_ind_needed[0]].append(prog_data[community_ind_needed[1]])
    prog_data[community_ind_needed[0]] = [prog_data[community_ind_needed[0]]]
    v = prog_data.pop(community_ind_needed[1])
    m = len(communities)

    print('All communities present      :-',prog_data)
    print('Communities merged in this step                 :-',prog_data[community_ind_needed[0]])
    print('#Communities After clustering     :-',m)
    print('\n')

end_time = time.time()
print("\ntime taken = ",end_time-start_time)

