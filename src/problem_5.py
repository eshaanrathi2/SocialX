# -*- coding: utf-8 -*-
"""Round 2 Q 2 Final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QlX_bVVe_eTB-UQCrYk_JqpJp5zCSpfp
"""

import networkx as nx
import matplotlib.pyplot as plt
import numpy as np

G = nx.barabasi_albert_graph(250, 10)

plt.figure(figsize =(20, 20))
nx.draw_networkx(G, with_labels = True, node_color ='blue')

for entry in nx.generate_adjlist(G):       # to print the adjacency list of the network created
    print(entry)

p_map = {}            #it is used to store the probability of outgoing edges from vertices of the network
adj_list = {}

for entry in nx.generate_adjlist(G):
    entry = list(map(int,entry.split()))
    node = entry[0]                #node: vertex in question whose outgoing edges we will look at
    size = len(entry)-1             #count of outgoing edges/ neighbours of node in each iteration
    p_list = []
    r_sum=0

    #inner loop 1
    for i in range(size):          #for node, we are creating random numbers having count = edges connected to the node; and appending the random numbers to a list
        r1 = np.random.rand()
        p_list.append(r1)
        r_sum+=r1

    #inner loop 2
    for i in range(size):        #this loop normalizes the random values stored in the list and gives the activation probability value for each connected edge to a node
        p_list[i]/=r_sum

    #inner loop 3
    for i in range(1,len(entry)):             #this loop is to create an adjacency list and a dictionary whose entries correspond to probability values of edges
        p_map[(node,entry[i])]=p_list[i-1]
        if(node not in adj_list):
            adj_list[node]=[]
        adj_list[node].append(entry[i])

print(adj_list)

for i in range(0,5):
    visited = [False] * 250
    queueBFS = []                            #a queue for BFS
    s=np.random.randint(0,250)        #to select a random node as seed node s
    queueBFS.append(s)
    visited[s] = True               #marking seed node as visited
    activated_nodes = []
    while queueBFS:
        s = queueBFS.pop(0)
        activated_nodes.append(s)
        if(s not in adj_list):
            continue
        for i in adj_list[s]:
            r = np.random.rand()/len(adj_list[s])    #to normalize the random number generated
            if visited[i] == False and r < p_map[(s,i)]:
                queueBFS.append(i)
                visited[i] = True
    print(f'Activated Nodes : {activated_nodes}')
    print(f'Count of activated nodes:{len(activated_nodes)}')

